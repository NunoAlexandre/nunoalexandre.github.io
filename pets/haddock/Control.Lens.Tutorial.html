<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta name="viewport" content="width=device-width, initial-scale=1"><link href="https://fonts.googleapis.com/css?family=PT+Sans:400,400i,700" rel="stylesheet"><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Control.Lens.Tutorial</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_Control-Lens-Tutorial.html");};
//]]>
</script></head><body><div id="package-header"><div class="caption">lens-tutorial-1.0.3: Tutorial for the lens library</div><ul class="links" id="page-menu"><li><a href="src/Control-Lens-Tutorial.html">Source</a></li><li><a href="/package/lens-tutorial-1.0.3">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>None</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Control.Lens.Tutorial</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">Motivation</a></li><li><a href="#g:2">Lenses</a></li><li><a href="#g:3">Accessor notation</a></li><li><a href="#g:4">First-class</a></li><li><a href="#g:5">Traversals</a></li><li><a href="#g:6">Types</a></li><li><a href="#g:7">Drawbacks</a></li><li><a href="#g:8">Conclusion</a></li><li><a href="#g:9">Exports</a></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>This <code>lens</code> tutorial targets Haskell beginners and assumes only basic
    familiarity with Haskell.  By the end of this tutorial you should:</p><ul><li>understand what problems the <code>lens</code> library solves,</li><li>know when it is appropriate to use the <code>lens</code> library,</li><li>be proficient in the most common <code>lens</code> idioms,</li><li>understand the drawbacks of using lenses, and:</li><li>know where to look if you wish to learn more advanced tricks.</li></ul><p>If you would like to follow along with these examples, just import this
    module:</p><pre>$ ghci
&gt;&gt;&gt; import Control.Lens.Tutorial</pre></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><span class="keyword">data</span> <a href="#t:Atom">Atom</a> = <a href="#v:Atom">Atom</a> {<ul class="subs"><li><a href="#v:_element">_element</a> :: <a href="/package/base-4.9.1.0/docs/Data-String.html#t:String">String</a></li><li><a href="#v:_point">_point</a> :: <a href="Control-Lens-Tutorial.html#t:Point">Point</a></li></ul>}</li><li class="src short"><a href="#v:element">element</a> :: <a href="/package/lens-4.15.3/docs/Control-Lens-Type.html#t:Lens-39-">Lens'</a> <a href="Control-Lens-Tutorial.html#t:Atom">Atom</a> <a href="/package/base-4.9.1.0/docs/Data-String.html#t:String">String</a></li><li class="src short"><a href="#v:point">point</a> :: <a href="/package/lens-4.15.3/docs/Control-Lens-Type.html#t:Lens-39-">Lens'</a> <a href="Control-Lens-Tutorial.html#t:Atom">Atom</a> <a href="Control-Lens-Tutorial.html#t:Point">Point</a></li><li class="src short"><span class="keyword">data</span> <a href="#t:Point">Point</a> = <a href="#v:Point">Point</a> {<ul class="subs"><li><a href="#v:_x">_x</a> :: <a href="/package/base-4.9.1.0/docs/Prelude.html#t:Double">Double</a></li><li><a href="#v:_y">_y</a> :: <a href="/package/base-4.9.1.0/docs/Prelude.html#t:Double">Double</a></li></ul>}</li><li class="src short"><a href="#v:x">x</a> :: <a href="/package/lens-4.15.3/docs/Control-Lens-Type.html#t:Lens-39-">Lens'</a> <a href="Control-Lens-Tutorial.html#t:Point">Point</a> <a href="/package/base-4.9.1.0/docs/Prelude.html#t:Double">Double</a></li><li class="src short"><a href="#v:y">y</a> :: <a href="/package/lens-4.15.3/docs/Control-Lens-Type.html#t:Lens-39-">Lens'</a> <a href="Control-Lens-Tutorial.html#t:Point">Point</a> <a href="/package/base-4.9.1.0/docs/Prelude.html#t:Double">Double</a></li><li class="src short"><span class="keyword">data</span> <a href="#t:Molecule">Molecule</a> = <a href="#v:Molecule">Molecule</a> {<ul class="subs"><li><a href="#v:_atoms">_atoms</a> :: [<a href="Control-Lens-Tutorial.html#t:Atom">Atom</a>]</li></ul>}</li><li class="src short"><a href="#v:atoms">atoms</a> :: <a href="/package/lens-4.15.3/docs/Control-Lens-Type.html#t:Iso-39-">Iso'</a> <a href="Control-Lens-Tutorial.html#t:Molecule">Molecule</a> [<a href="Control-Lens-Tutorial.html#t:Atom">Atom</a>]</li><li class="src short"><span class="keyword">data</span> <a href="#t:Pair">Pair</a> a = <a href="#v:Pair">Pair</a> a a</li><li class="src short"><a href="#v:traverse">traverse</a> :: <a href="/package/base-4.9.1.0/docs/Data-Traversable.html#t:Traversable">Traversable</a> t =&gt; <span class="keyword">forall</span> f a b. <a href="/package/base-4.9.1.0/docs/Control-Applicative.html#t:Applicative">Applicative</a> f =&gt; (a -&gt; f b) -&gt; t a -&gt; f (t b)</li></ul></div><div id="interface"><h1 id="g:1">Motivation</h1><div class="doc"><p>The simplest problem that the <code>lens</code> library solves is updating deeply
     nested records.  Suppose you had the following nested Haskell data types:</p><pre>data Atom = Atom { _element :: String, _point :: Point }

data Point = Point { _x :: Double, _y :: Double }</pre><p>If you wanted to increase the <code>x</code> coordinate of an <code><a href="Control-Lens-Tutorial.html#t:Atom">Atom</a></code> by one unit, you
     would have to write something like this in Haskell:</p><pre>shiftAtomX :: Atom -&gt; Atom
shiftAtomX (Atom e (Point x y)) = Atom e (Point (x + 1) y)</pre><p>This unpacking and repacking of data types grows increasingly difficult the
     more fields you add to each data type or the more deeply nested your data
     structures become.</p><p>The <code>lens</code> library solves this problem by letting you instead write:</p><pre>-- atom.hs

{-# LANGUAGE TemplateHaskell #-}

import Control.Lens hiding (element)

data Atom = Atom { _element :: String, _point :: Point } deriving (Show)

data Point = Point { _x :: Double, _y :: Double } deriving (Show)

makeLenses ''Atom
makeLenses ''Point

shiftAtomX :: Atom -&gt; Atom
shiftAtomX = over (point . x) (+ 1)</pre><p>Let's convince ourselves that this works:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let atom = Atom { _element = &quot;C&quot;, _point = Point { _x = 1.0, _y = 2.0 } }
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>shiftAtomX atom
</code></strong>Atom {_element = &quot;C&quot;, _point = Point {_x = 2.0, _y = 2.0}}
</pre><p>The above solution does not change no matter how many fields we add to
     <code>Atom</code> or <code>Point</code>.</p><p>Now suppose that we added yet another data structure:</p><pre>data Molecule = Molecule { _atoms :: [Atom] } deriving (Show)</pre><p>We could shift an entire <code>Molecule</code> by writing:</p><pre>makeLenses ''Molecule

shiftMoleculeX :: Molecule -&gt; Molecule
shiftMoleculeX = over (atoms . traverse . point . x) (+ 1)</pre><p>Again, this works the way we expect:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let atom1 = Atom { _element = &quot;C&quot;, _point = Point { _x = 1.0, _y = 2.0 } }
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let atom2 = Atom { _element = &quot;O&quot;, _point = Point { _x = 3.0, _y = 4.0 } }
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let molecule = Molecule { _atoms = [atom1, atom2] }
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>shiftMoleculeX molecule  -- Output formatted for clarity
</code></strong>Molecule {_atoms = [Atom {_element = &quot;C&quot;, _point = Point {_x = 2.0, _y = 2.0}},Atom {_element = &quot;O&quot;, _point = Point {_x = 4.0, _y = 4.0}}]}
</pre><p>... or formatted for clarity:</p><pre>Molecule
    { _atoms =
        [ Atom { _element = &quot;C&quot;, _point = Point { _x = 2.0, _y = 2.0 } }
        , Atom { _element = &quot;O&quot;, _point = Point { _x = 4.0, _y = 4.0 } }
        ]
    }</pre><p>Many people stumble across lenses while trying to solve this common problem
     of working with data structures with a large number of fields or deeply
     nested values.  These sorts of situations arise commonly in:</p><ul><li>games with complex and deeply nested state</li><li>scientific data formats</li><li>sensor or instrument output</li><li>web APIs</li><li>XML and JSON</li><li>enterprise code where data structures can have tens, hundreds, or even
       thousands of fields (true story!)</li></ul></div><h1 id="g:2">Lenses</h1><div class="doc"><p>You might have some basic questions like:</p><p><em>Question:</em> What is a lens?</p><p><em>Answer:</em> A lens is a first class getter and setter</p><p>We already saw how to use lenses to update values using <code><a href="/package/lens-4.15.3/docs/Control-Lens-Setter.html#v:over">over</a></code>, but we can
    also use lenses to retrieve values using <code><a href="/package/lens-4.15.3/docs/Control-Lens-Getter.html#v:view">view</a></code>:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let atom = Atom { _element = &quot;C&quot;, _point = Point { _x = 1.0, _y = 2.0 } }
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>view (point . x) atom
</code></strong>1.0
</pre><p>In other words, lenses package both &quot;get&quot; and &quot;set&quot; functionality into
    a single value (the lens).  You could pretend that a lens is a record
    with two fields:</p><pre>data Lens a b = Lens
    { view :: a -&gt; b
    , over :: (b -&gt; b) -&gt; (a -&gt; a)
    }</pre><p>That's not how lenses are actually implemented, but it's a useful
    starting intuition.</p><p><em>Question:</em> What is the type of a lens?</p><p><em>Answer:</em> We used two lenses in the above <code>Atom</code> example, with these types:</p><pre>point :: Lens' Atom  Point
x     :: Lens' Point Double</pre><p>The <code>point</code> lens contains all the information we need to get or set the
    <code>_point</code> field of the <code>Atom</code> type (which is a <code><a href="Control-Lens-Tutorial.html#t:Point">Point</a></code>).  Similarly, the <code>x</code>
    lens contains all the information we need to get or set the <code>_x</code> field of
    the <code>Point</code> data type (which is a <code><a href="/package/base-4.9.1.0/docs/Prelude.html#t:Double">Double</a></code>).</p><p>The convention for the <code><a href="/package/lens-4.15.3/docs/Control-Lens-Type.html#t:Lens-39-">Lens'</a></code> type parameters is:</p><pre>--    +-- Bigger type
--    |
--    v
Lens' bigger smaller
--           ^
--           |
--           +--  Smaller type within the bigger type</pre><p>The actual definition of <code><a href="/package/lens-4.15.3/docs/Control-Lens-Type.html#t:Lens-39-">Lens'</a></code> is:</p><pre>type Lens' a b = forall f . Functor f =&gt; (b -&gt; f b) -&gt; (a -&gt; f a)</pre><p>You might wonder how you can fit both getter and setter functionality in
    a single value like this.  The trick is that we get to pick what <code><a href="/package/base-4.9.1.0/docs/Data-Functor.html#t:Functor">Functor</a></code>
    we specialize <code>f</code> to and depending on which <code><a href="/package/base-4.9.1.0/docs/Data-Functor.html#t:Functor">Functor</a></code> we pick we get
    different features.</p><p>For example, if you pick <code>(f = <code><a href="/package/base-4.9.1.0/docs/Data-Functor-Identity.html#t:Identity">Identity</a></code>)</code>:</p><pre>type ASetter' a b   = (b -&gt; Identity b) -&gt; (a -&gt; Identity a)

-- ... equivalent to: (b -&gt;          b) -&gt; (a -&gt;          a)</pre><p>... you can build an <code><a href="/package/lens-4.15.3/docs/Control-Lens-Setter.html#v:over">over</a></code>-like function.</p><p>Similarly, if you pick <code>(f = <code><a href="/package/base-4.9.1.0/docs/Data-Functor-Const.html#t:Const">Const</a></code> b)</code>:</p><pre>type Getting b a b  = (b -&gt; Const b b) -&gt; (a -&gt; Const b a)

-- ... equivalent to: (b -&gt;       b  ) -&gt; (a -&gt;       b  )</pre><p>... and if you apply a function of that type to <code><a href="/package/base-4.9.1.0/docs/Data-Function.html#v:id">id</a></code> then you get a
    <code><a href="/package/lens-4.15.3/docs/Control-Lens-Getter.html#v:view">view</a></code>-like function</p><pre>--                                        (a -&gt;       b  )</pre><p>Those are not the only two <code><a href="/package/base-4.9.1.0/docs/Data-Functor.html#t:Functor">Functor</a></code>s we can pick.  In fact, we can do a
    lot more with lenses than just get and set values, but those are the two
    most commonly used features.</p><p><em>Question:</em> How do I create lenses?</p><p><em>Answer:</em> You can either auto-generate them using Template Haskell or
    create them by hand</p><p>In our <code>Atom</code> example, we auto-generated the lenses using Template Haskell,
    like this:</p><pre>makeLenses ''Atom
makeLenses ''Point</pre><p>This created four lenses of the following types:</p><pre>element :: Lens' Atom String
point   :: Lens' Atom Point
x       :: Lens' Point Double
y       :: Lens' Point Double</pre><p><code><a href="/package/lens-4.15.3/docs/Control-Lens-TH.html#v:makeLenses">makeLenses</a></code> creates one lens per field prefixed with an underscore.  The
    lens has the same name as the field without the underscore.</p><p>However, sometimes Template Haskell is not an option, so we can also use
    the <code><a href="/package/lens-4.15.3/docs/Control-Lens-Lens.html#v:lens">lens</a></code> utility function to build lenses.  This utility has type:</p><pre>lens :: (a -&gt; b) -&gt; (a -&gt; b -&gt; a) -&gt; Lens' a b</pre><p>The first argument is a &quot;getter&quot; (a way to extract a <code>'b'</code> from an
    <code>'a'</code>).  The second argument is a &quot;setter&quot; (given a <code>b</code>, update an
    <code>a</code>).  The result is a <code><a href="/package/lens-4.15.3/docs/Control-Lens-Type.html#t:Lens-39-">Lens'</a></code> built from the getter and setter.  You would
    use <code><a href="/package/lens-4.15.3/docs/Control-Lens-Lens.html#v:lens">lens</a></code> like this:</p><pre>point :: Lens' Atom Point
point = lens _point (\atom newPoint -&gt; atom { _point = newPoint })</pre><p>You can even define lenses without incurring a dependency on the <code>lens</code>
    library.  Remember that lenses are just higher-order functions over
    <code><a href="/package/base-4.9.1.0/docs/Data-Functor.html#t:Functor">Functor</a></code>s, so we could instead write:</p><pre>-- point :: Lens' Atom Point
point :: Functor f =&gt; (Point -&gt; f Point) -&gt; Atom -&gt; f Atom
point k atom = fmap (\newPoint -&gt; atom { _point = newPoint }) (k (_point atom))</pre><p>This means that you can provide lenses for your library's types without
    depending on the <code>lens</code> library.  All you need is the <code><a href="/package/base-4.9.1.0/docs/Data-Functor.html#v:fmap">fmap</a></code> function,
    which is provided by the Haskell Prelude.</p><p><em>Question:</em> How do I combine lenses?</p><p><em>Answer:</em> You compose them, using function composition (Yes, really!)</p><p>You can think of the function composition operator as having this type:</p><pre>(.) :: Lens' a b -&gt; Lens' b c -&gt; Lens' a c</pre><p>We can compose lenses using function composition because <code><a href="/package/lens-4.15.3/docs/Control-Lens-Type.html#t:Lens-39-">Lens'</a></code> is a
    type synonym for a higher-order function:</p><pre>type Lens' a b = forall f . Functor f =&gt; (b -&gt; f b) -&gt; (a -&gt; f a)</pre><p>So under the hood we are composing two higher-order functions to get back a
    new higher-order function:</p><pre>(.) :: Functor f
    =&gt; ((b -&gt; f b) -&gt; (a -&gt; f a))
    -&gt; ((c -&gt; f c) -&gt; (b -&gt; f b))
    -&gt; ((c -&gt; f c) -&gt; (a -&gt; f a))</pre><p>In our original <code>Atom</code> example, we composed the <code>point</code> and <code>x</code> lenses to
    create a new composite lens:</p><pre>point     :: Lens' Atom Point
x         :: Lens' Point Double

point . x :: Lens' Atom Double</pre><p>This composite lens lets us get or set the <code>x</code> coordinate of an <code>Atom</code>.
    We can use <code><a href="/package/lens-4.15.3/docs/Control-Lens-Setter.html#v:over">over</a></code> and <code><a href="/package/lens-4.15.3/docs/Control-Lens-Getter.html#v:view">view</a></code> on the composite <code><a href="/package/lens-4.15.3/docs/Control-Lens-Type.html#t:Lens-39-">Lens'</a></code> and they will behave
    exactly the way we expect:</p><pre>view (point . x) :: Atom -&gt; Double

over (point . x) :: (Double -&gt; Double) -&gt; (Atom -&gt; Atom)</pre><p><em>Question:</em> How do I consume lenses?</p><p><em>Answer:</em> Using <code><a href="/package/lens-4.15.3/docs/Control-Lens-Getter.html#v:view">view</a></code>, <code><a href="/package/lens-4.15.3/docs/Control-Lens-Setter.html#v:set">set</a></code> or <code><a href="/package/lens-4.15.3/docs/Control-Lens-Setter.html#v:over">over</a></code></p><p>Here are their types:</p><pre>view :: Lens' a b -&gt; a -&gt; b

over :: Lens' a b -&gt; (b -&gt; b) -&gt; a -&gt; a

set  :: Lens' a b -&gt;       b  -&gt; a -&gt; a
set lens b = over lens (\_ -&gt; b)</pre><p><code><a href="/package/lens-4.15.3/docs/Control-Lens-Getter.html#v:view">view</a></code> and <code><a href="/package/lens-4.15.3/docs/Control-Lens-Setter.html#v:over">over</a></code> are the two fundamental functions on lenses.  <code><a href="/package/lens-4.15.3/docs/Control-Lens-Setter.html#v:set">set</a></code> is
    just a special case of <code><a href="/package/lens-4.15.3/docs/Control-Lens-Setter.html#v:over">over</a></code>.</p><p><code><a href="/package/lens-4.15.3/docs/Control-Lens-Getter.html#v:view">view</a></code> and <code><a href="/package/lens-4.15.3/docs/Control-Lens-Setter.html#v:over">over</a></code> are fundamental because they distribute over lens
    composition:</p><pre>view (lens1 . lens2) = (view lens2) . (view lens1)

view id = id</pre><pre>over (lens1 . lens2) = (over lens1) . (over lens2)

over id = id</pre><p><em>Question:</em> What else do I need to know?</p><p><em>Answer:</em> That's pretty much it!</p><p>For 90% of use cases, you just:</p><ul><li>Create lenses (using <code>makeLens</code>, <code><a href="/package/lens-4.15.3/docs/Control-Lens-Lens.html#v:lens">lens</a></code> or plain-old <code><a href="/package/base-4.9.1.0/docs/Data-Functor.html#v:fmap">fmap</a></code>)</li><li>Compose them (using (<code><a href="/package/base-4.9.1.0/docs/Data-Function.html#v:.">.</a></code>))</li><li>Consume them (using <code><a href="/package/lens-4.15.3/docs/Control-Lens-Getter.html#v:view">view</a></code>, <code><a href="/package/lens-4.15.3/docs/Control-Lens-Setter.html#v:set">set</a></code>, and <code><a href="/package/lens-4.15.3/docs/Control-Lens-Setter.html#v:over">over</a></code>)</li></ul><p>You could actually stop reading here if you are in a hurry since this
    covers the overwhelmingly common use case for the library.  On the other
    hand, keep reading if you would like to learn additional tricks and
    features.</p></div><h1 id="g:3">Accessor notation</h1><div class="doc"><p>You might be used to object-oriented languages where you could retrieve a
    nested field using:</p><pre>atom.point.x</pre><p>You can do almost the exact same thing using the <code>lens</code> library, except
    that the first dot will have a <code>^</code> right before the dot:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let atom = Atom { _element = &quot;C&quot;, _point = Point { _x = 1.0, _y = 2.0 } }
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>atom^.point.x
</code></strong>1.0
</pre><p>You can better understand why this works, by adding whitespace and
    explicit parentheses:</p><pre>atom ^. (point . x)</pre><p>This trick uses (<code><a href="/package/lens-4.15.3/docs/Control-Lens-Getter.html#v:-94-.">^.</a></code>), which is an infix operator equivalent to <code><a href="/package/lens-4.15.3/docs/Control-Lens-Getter.html#v:view">view</a></code>:</p><pre>(^.) :: a -&gt; Lens' a b -&gt; b
x ^. l = view l x</pre><p>... and you just keep adding dots after that for each lens you compose.
    This gives the appearance of object-oriented accessors if you omit the
    whitespace around the operators.</p></div><h1 id="g:4">First-class</h1><div class="doc"><p>Lenses are &quot;first class&quot; values, meaning that you can manipulate them
    using ordinary functional programming techniques.  You can take them as
    inputs, return them as outputs, or stick them in data structures.  Anything
    goes!</p><p>For example, suppose we don't want to define separate shift functions for
    <code>Atom</code>s and <code>Molecule</code>s:</p><pre>shiftAtomX :: Atom -&gt; Atom
shiftAtomX = over (point . x) (+ 1)</pre><pre>shiftMoleculeX :: Molecule -&gt; Molecule
shiftMoleculeX = over (atoms . traverse . point . x) (+ 1)</pre><p>We can instead unify them into a single function by parametrizing the
    shift function on the lens:</p><pre>shift lens = over lens (+ 1)</pre><p>This lets us write:</p><pre>shift (point . x) :: Atom -&gt; Atom

shift (atoms . traverse . point . x) :: Molecule -&gt; Molecule</pre><p>Even better, we can define synonyms for our composite lenses:</p><pre>atomX :: Lens' Atom Double
atomX = point . x

-- We'll learn what `Traversal` means shortly
moleculeX :: Traversal' Molecule Double
moleculeX = atoms . traverse . point . x</pre><p>Now we can write code almost identical to the original code:</p><pre>shift atomX :: Atom -&gt; Atom

shift moleculeX :: Molecule -&gt; Molecule</pre><p>... but we also get several other utilities for free:</p><pre>set atomX :: Double -&gt; Atom -&gt; Atom

set moleculeX :: Double -&gt; Molecule -&gt; Molecule

view atomX :: Atom -&gt; Double

-- We can't use `view` for `Traversal'`s.  Read on to find out why
toListOf moleculeX :: Molecule -&gt; [Double]</pre><p>That's much more reusable, but you might wonder what this <code><a href="/package/lens-4.15.3/docs/Control-Lens-Type.html#t:Traversal-39-">Traversal'</a></code> and
    <code><a href="/package/lens-4.15.3/docs/Control-Lens-Fold.html#v:toListOf">toListOf</a></code> business is all about.</p></div><h1 id="g:5">Traversals</h1><div class="doc"><p><em>Question:</em> What is a traversal?</p><p><em>Answer:</em> A first class getter and setter for an arbitrary number of values</p><p>A traversal lets you get all the values it points to as a list and it also
     lets you update or set all the values it points to.  Think of a traversal
     as a record with two fields:</p><pre>data Traversal' a b = Traversal'
    { toListOf :: a -&gt; [b]
    , over     :: (b -&gt; b) -&gt; (a -&gt; a)
    }</pre><p>That's not how traversals are actually implemented, but it's a useful
     starting intuition.</p><p>We can still use <code><a href="/package/lens-4.15.3/docs/Control-Lens-Setter.html#v:over">over</a></code> and <code><a href="/package/lens-4.15.3/docs/Control-Lens-Setter.html#v:set">set</a></code> (a special case of <code><a href="/package/lens-4.15.3/docs/Control-Lens-Setter.html#v:over">over</a></code>) with a
     traversal, but we use <code><a href="/package/lens-4.15.3/docs/Control-Lens-Fold.html#v:toListOf">toListOf</a></code> instead of <code><a href="/package/lens-4.15.3/docs/Control-Lens-Getter.html#v:view">view</a></code>.</p><p><em>Question:</em> What is the type of a traversal?</p><p><em>Answer:</em> We used one traversal in the above <code>Molecule</code> example:</p><pre>moleculeX :: Traversal' Molecule Double</pre><p>This <code><a href="/package/lens-4.15.3/docs/Control-Lens-Type.html#t:Traversal-39-">Traversal'</a></code> lets us get or set an arbitrary number of x coordinates,
     each of which is a <code><a href="/package/base-4.9.1.0/docs/Prelude.html#t:Double">Double</a></code>.  There could be less than one x coordinate
     (i.e. 0 coordinates) or more than one x coordinate.  Contrast this with a
     <code><a href="/package/lens-4.15.3/docs/Control-Lens-Type.html#t:Lens-39-">Lens'</a></code> which can only get or set exactly one value.</p><p>Like <code><a href="/package/lens-4.15.3/docs/Control-Lens-Type.html#t:Lens-39-">Lens'</a></code>, <code><a href="/package/lens-4.15.3/docs/Control-Lens-Type.html#t:Traversal-39-">Traversal'</a></code> is a type synonym for a higher-order function:</p><pre>type Traversal' a b = forall f . Applicative f =&gt; (b -&gt; f b) -&gt; (a -&gt; f a)

type Lens'      a b = forall f . Functor     f =&gt; (b -&gt; f b) -&gt; (a -&gt; f a)</pre><p>Notice that the only difference between a <code><a href="/package/lens-4.15.3/docs/Control-Lens-Type.html#t:Lens-39-">Lens'</a></code> and a <code><a href="/package/lens-4.15.3/docs/Control-Lens-Type.html#t:Traversal-39-">Traversal'</a></code> is the
     type class constraint.  A <code><a href="/package/lens-4.15.3/docs/Control-Lens-Type.html#t:Lens-39-">Lens'</a></code> has a <code><a href="/package/base-4.9.1.0/docs/Data-Functor.html#t:Functor">Functor</a></code> constraint and
     <code><a href="/package/lens-4.15.3/docs/Control-Lens-Type.html#t:Traversal-39-">Traversal'</a></code> has an <code><a href="/package/base-4.9.1.0/docs/Control-Applicative.html#t:Applicative">Applicative</a></code> constraint.  This means that any <code><a href="/package/lens-4.15.3/docs/Control-Lens-Type.html#t:Lens-39-">Lens'</a></code>
     is automatically also a valid <code><a href="/package/lens-4.15.3/docs/Control-Lens-Type.html#t:Traversal-39-">Traversal'</a></code> (since <code><a href="/package/base-4.9.1.0/docs/Data-Functor.html#t:Functor">Functor</a></code> is a superclass
     of <code><a href="/package/base-4.9.1.0/docs/Control-Applicative.html#t:Applicative">Applicative</a></code>).</p><p>Since every <code><a href="/package/lens-4.15.3/docs/Control-Lens-Type.html#t:Lens-39-">Lens'</a></code> is a <code><a href="/package/lens-4.15.3/docs/Control-Lens-Type.html#t:Traversal-39-">Traversal'</a></code>, all of our example lenses also
     double as traversals:</p><pre>atoms   :: Traversal' Molecule [Atom]
element :: Traversal' Atom     String
point   :: Traversal' Atom     Point
x       :: Traversal' Point    Double
y       :: Traversal' Point    Double</pre><p>We actually used yet another <code><a href="/package/lens-4.15.3/docs/Control-Lens-Type.html#t:Traversal-39-">Traversal'</a></code>, which was <code><a href="Control-Lens-Tutorial.html#v:traverse">traverse</a></code> (from
     <a href="/package/base-4.9.1.0/docs/Data-Traversable.html">Data.Traversable</a>):</p><pre>traverse :: Traversable t =&gt; Traversal' (t a) a</pre><p>This works because the <code><a href="/package/lens-4.15.3/docs/Control-Lens-Type.html#t:Traversal-39-">Traversal'</a></code> type synonym expands out to:</p><pre>traverse :: (Applicative f, Traversable t) =&gt; (a -&gt; f a) -&gt; t a -&gt; f (t a)</pre><p>... which is exactly the traditional type signature of <code><a href="Control-Lens-Tutorial.html#v:traverse">traverse</a></code>.</p><p>In our <code>Molecule</code> example, we were using the special case where <code>t = []</code>:</p><pre>traverse :: Traversal' [a] a</pre><p>In Haskell, you can derive <code><a href="/package/base-4.9.1.0/docs/Data-Functor.html#t:Functor">Functor</a></code>, <code><a href="/package/base-4.9.1.0/docs/Data-Foldable.html#t:Foldable">Foldable</a></code> and
     <code><a href="/package/base-4.9.1.0/docs/Data-Traversable.html#t:Traversable">Traversable</a></code> for many data types using the <code>DeriveFoldable</code> and
     <code>DeriveTraversable</code> extensions.  This means that you can autogenerate a
     valid <code><a href="Control-Lens-Tutorial.html#v:traverse">traverse</a></code> for these data types:</p><pre>{-# LANGUAGE DeriveFoldable    #-}
{-# LANGUAGE DeriveFunctor     #-}
{-# LANGUAGE DeriveTraversable #-}

import Control.Lens
import Data.Foldable

data Pair a = Pair a a deriving (Functor, Foldable, Traversable)</pre><p>We could then use <code><a href="Control-Lens-Tutorial.html#v:traverse">traverse</a></code> to navigate from <code><a href="Control-Lens-Tutorial.html#t:Pair">Pair</a></code> to its two children:</p><pre>traverse :: Traversal' (Pair a) a

over traverse :: (a -&gt; a) -&gt; (Pair a -&gt; Pair a)

over traverse (+ 1) (Pair 3 4) = Pair 4 5</pre><p><em>Question:</em> How do I create traversals?</p><p><em>Answer:</em> There are three main ways to create primitive traversals:</p><ul><li><code><a href="Control-Lens-Tutorial.html#v:traverse">traverse</a></code> is a <code><a href="/package/lens-4.15.3/docs/Control-Lens-Type.html#t:Traversal-39-">Traversal'</a></code> that you get for any type that implements
       <code><a href="/package/base-4.9.1.0/docs/Data-Traversable.html#t:Traversable">Traversable</a></code></li><li>Every <code><a href="/package/lens-4.15.3/docs/Control-Lens-Type.html#t:Lens-39-">Lens'</a></code> will also type-check as a <code><a href="/package/lens-4.15.3/docs/Control-Lens-Type.html#t:Traversal-39-">Traversal'</a></code></li><li>You can use Template Haskell to generate <code><a href="/package/lens-4.15.3/docs/Control-Lens-Type.html#t:Traversal-39-">Traversal'</a></code>s using <code><a href="/package/lens-4.15.3/docs/Control-Lens-Internal-PrismTH.html#v:makePrisms">makePrisms</a></code>
       since every <code><a href="/package/lens-4.15.3/docs/Control-Lens-Type.html#t:Prism-39-">Prism'</a></code> is also a <code><a href="/package/lens-4.15.3/docs/Control-Lens-Type.html#t:Traversal-39-">Traversal'</a></code> (not covered in this
       tutorial)</li></ul><p><em>Question:</em> How do I combine traversals?</p><p><em>Answer:</em> You compose them, using function composition</p><p>You can think of the function composition operator as having this type:</p><pre>(.) :: Traversal' a b -&gt; Traversal' b c -&gt; Traversal' a c</pre><p>We can compose traversals using function composition because a
     <code><a href="/package/lens-4.15.3/docs/Control-Lens-Type.html#t:Traversal-39-">Traversal'</a></code> is a type synonym for a higher-order function:</p><pre>type Traversal' a b = forall f . Applicative f =&gt; (b -&gt; f b) -&gt; (a -&gt; f a)</pre><p>So under the hood we are composing two functions to get back a new
     function:</p><pre>(.) :: Applicative f
    =&gt; ((b -&gt; f b) -&gt; (a -&gt; f a))
    -&gt; ((c -&gt; f c) -&gt; (b -&gt; f b))
    -&gt; ((c -&gt; f c) -&gt; (a -&gt; f a))</pre><p>In our original <code>Molecule</code> example, we composed four <code><a href="/package/lens-4.15.3/docs/Control-Lens-Type.html#t:Traversal-39-">Traversal'</a></code>s
     together to create a new <code><a href="/package/lens-4.15.3/docs/Control-Lens-Type.html#t:Traversal-39-">Traversal'</a></code>:</p><pre>-- Remember that `atoms`, `point`, and `x` are also `Traversal'`s
atoms                        :: Traversal' Molecule [Atom]
traverse                     :: Traversal' [Atom]   Atom
point                        :: Traversal' Atom     Point
x                            :: Traversal' Point    Double

-- Now compose them
atoms                        :: Traversal' Molecule [Atom]
atoms . traverse             :: Traversal' Molecule Atom
atoms . traverse . point     :: Traversal' Molecule Point
atoms . traverse . point . x :: Traversal' Molecule Double</pre><p>This composite traversal lets us get or set the <code>x</code> coordinates of a
     <code>Molecule</code>.</p><pre>over (atoms . traverse . point . x)
    :: (Double -&gt; Double) -&gt; (Molecule -&gt; Molecule)

toListOf (atoms . traverse . point . x)
    :: Molecule -&gt; [Double]</pre><p><em>Question:</em> How do I consume traversals?</p><p><em>Answer:</em> Using <code><a href="/package/lens-4.15.3/docs/Control-Lens-Fold.html#v:toListOf">toListOf</a></code>, <code><a href="/package/lens-4.15.3/docs/Control-Lens-Setter.html#v:set">set</a></code> or <code><a href="/package/lens-4.15.3/docs/Control-Lens-Setter.html#v:over">over</a></code></p><p>Here are their types:</p><pre>toListOf :: Traversal' a b -&gt; a -&gt; [b]

over :: Traversal' a b -&gt; (b -&gt; b) -&gt; a -&gt; a

set  :: Traversal' a b -&gt;       b  -&gt; a -&gt; a
set traversal b = over traversal (\_ -&gt; b)</pre><p>Note that <code><a href="/package/lens-4.15.3/docs/Control-Lens-Fold.html#v:toListOf">toListOf</a></code> distributes over traversal composition:</p><pre>toListOf (traversal1 . traversal2) = (toListOf traversal1) &gt;=&gt; (toListOf traversal2)

toListOf id = return</pre><p>If you prefer object-oriented syntax you can also use (<code><a href="/package/lens-4.15.3/docs/Control-Lens-Fold.html#v:-94-..">^..</a></code>), which is an
 infix operator equivalent to <code><a href="/package/lens-4.15.3/docs/Control-Lens-Fold.html#v:toListOf">toListOf</a></code>:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>Pair 3 4 ^.. traverse
</code></strong>[3,4]
</pre></div><h1 id="g:6">Types</h1><div class="doc"><p>You might wonder why you can use <code><a href="/package/lens-4.15.3/docs/Control-Lens-Setter.html#v:over">over</a></code> on both a <code><a href="/package/lens-4.15.3/docs/Control-Lens-Type.html#t:Lens-39-">Lens'</a></code> and a
    <code><a href="/package/lens-4.15.3/docs/Control-Lens-Type.html#t:Traversal-39-">Traversal'</a></code> but you can only use <code><a href="/package/lens-4.15.3/docs/Control-Lens-Getter.html#v:view">view</a></code> on a <code><a href="/package/lens-4.15.3/docs/Control-Lens-Type.html#t:Lens-39-">Lens'</a></code>.  We can see why by
    studying the (simplified) type and implementation of <code><a href="/package/lens-4.15.3/docs/Control-Lens-Setter.html#v:over">over</a></code>:</p><pre>over :: ((b -&gt; Identity b) -&gt; (a -&gt; Identity a)) -&gt; (b -&gt; b) -&gt; a -&gt; a
over setter f x = runIdentity (setter (\y -&gt; Identity (f y)) x)</pre><p>To follow the implementation, just step slowly through the types.  Here
    are the types of the arguments to <code><a href="/package/lens-4.15.3/docs/Control-Lens-Setter.html#v:over">over</a></code>:</p><pre>setter :: (b -&gt; Identity b) -&gt; (a -&gt; Identity a)
f      :: b -&gt; b
x      :: a</pre><p>... and here are the types of the sub-expressions on the right-hand side:</p><pre>                     \y -&gt; Identity (f y)     :: b -&gt; Identity b
             setter (\y -&gt; Identity (f y))    :: a -&gt; Identity a
             setter (\y -&gt; Identity (f y)) x  ::      Identity a
runIdentity (setter (\y -&gt; Identity (f y)) x) ::               a</pre><p>We can replace <code>setter</code> with <code>point</code> and replace <code>x</code> with <code>atom</code> to see
     that this generates the correct code for updating an atom's point:</p><pre>  over point f atom

-- Definition of `over`
= runIdentity (point (\y -&gt; Identity (f y)) atom)

-- Definition of `point`
= runIdentity (fmap (\newPoint -&gt; atom { _point = newPoint }) (Identity (f (_point atom)))

-- fmap g (Identity y) = Identity (g y)
= runIdentity (Identity (atom { _point = f (_point atom) }))

-- runIdentity (Identity z) = z
= atom { _point = f (_point atom) }</pre><p>... which is exactly what we would have written by hand without lenses.</p><p>The reason <code><a href="/package/lens-4.15.3/docs/Control-Lens-Setter.html#v:over">over</a></code> works for both <code><a href="/package/lens-4.15.3/docs/Control-Lens-Type.html#t:Lens-39-">Lens'</a></code>es and <code><a href="/package/lens-4.15.3/docs/Control-Lens-Type.html#t:Traversal-39-">Traversal'</a></code>s is because
    <code><a href="/package/base-4.9.1.0/docs/Data-Functor-Identity.html#t:Identity">Identity</a></code> implements both <code><a href="/package/base-4.9.1.0/docs/Data-Functor.html#t:Functor">Functor</a></code> and <code><a href="/package/base-4.9.1.0/docs/Control-Applicative.html#t:Applicative">Applicative</a></code>:</p><pre>instance Functor     Identity where ...
instance Applicative Identity where ...</pre><p>So both the <code><a href="/package/lens-4.15.3/docs/Control-Lens-Type.html#t:Lens-39-">Lens'</a></code> type and <code><a href="/package/lens-4.15.3/docs/Control-Lens-Type.html#t:Traversal-39-">Traversal'</a></code> type synonyms:</p><pre>type Traversal' a b = forall f . Applicative f =&gt; (b -&gt; f b) -&gt; (a -&gt; f a)

type Lens'      a b = forall f . Functor     f =&gt; (b -&gt; f b) -&gt; (a -&gt; f a)</pre><p>... can both be specialized to use <code><a href="/package/base-4.9.1.0/docs/Data-Functor-Identity.html#t:Identity">Identity</a></code> in place of <code>f</code>:</p><pre>(b -&gt; Identity b) -&gt; (a -&gt; Identity a)</pre><p>... making them valid arguments to <code><a href="/package/lens-4.15.3/docs/Control-Lens-Setter.html#v:over">over</a></code>.</p><p>Now let's study the (simplified) type and implementation of <code><a href="/package/lens-4.15.3/docs/Control-Lens-Getter.html#v:view">view</a></code>:</p><pre>view :: ((b -&gt; Const b b) -&gt; (a -&gt; Const b a)) -&gt; a -&gt; b
view getter x = getConst (getter Const x)</pre><p>Again, we can walk slowly through the types of the arguments:</p><pre>getter :: (b -&gt; Const b b) -&gt; (a -&gt; Const b a)
x      :: a</pre><p>... and the types of the sub-expressions on the right-hand side:</p><pre>getter Const              :: a -&gt; Const b a
getter Const x            ::      Const b a
getConst (getter Const x) ::            b</pre><p>Let's see how this plays out for the <code>point</code> lens:</p><pre>  view point atom

-- Definition of `view`
= getConst (point Const atom)

-- Definition of `point`
= getConst (fmap (\newPoint -&gt; atom { _point = newPoint }) (Const (_point atom)))

-- fmap g (Const y) = Const y
= getConst (Const (_point atom))

-- getConst (Const z) = z
= _point atom</pre><p>... which is exactly what we would have written by hand without lenses.</p><p><code><a href="/package/lens-4.15.3/docs/Control-Lens-Getter.html#v:view">view</a></code> accepts <code><a href="/package/lens-4.15.3/docs/Control-Lens-Type.html#t:Lens-39-">Lens'</a></code>es because <code><a href="/package/base-4.9.1.0/docs/Data-Functor-Const.html#t:Const">Const</a></code> implements <code><a href="/package/base-4.9.1.0/docs/Data-Functor.html#t:Functor">Functor</a></code>:</p><pre>instance Functor (Const b)</pre><p>... so the <code><a href="/package/lens-4.15.3/docs/Control-Lens-Type.html#t:Lens-39-">Lens'</a></code> type synonym:</p><pre>type Lens' a b = forall f . Functor f =&gt; (b -&gt; f b) -&gt; (a -&gt; f a)</pre><p>... can be specialized to use <code>(<code><a href="/package/base-4.9.1.0/docs/Data-Functor-Const.html#t:Const">Const</a></code> b)</code> in place of <code>f</code>:</p><pre>(b -&gt; Const b b) -&gt; (a -&gt; Const b a)</pre><p>... making it a valid argument to <code><a href="/package/lens-4.15.3/docs/Control-Lens-Getter.html#v:view">view</a></code>.</p><p>Interestingly, <code><a href="/package/base-4.9.1.0/docs/Data-Functor-Const.html#t:Const">Const</a></code> implements also <code><a href="/package/base-4.9.1.0/docs/Control-Applicative.html#t:Applicative">Applicative</a></code>, but with a
    constraint:</p><pre>instance Monoid b =&gt; Applicative (Const b)</pre><p>This implies that we *can* use <code><a href="/package/lens-4.15.3/docs/Control-Lens-Getter.html#v:view">view</a></code> on a <code><a href="/package/lens-4.15.3/docs/Control-Lens-Type.html#t:Traversal-39-">Traversal'</a></code>, but only if the
    value that we extract is a <code><a href="/package/base-4.9.1.0/docs/Data-Monoid.html#t:Monoid">Monoid</a></code>.  Let's try this out:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let atom1 = Atom { _element = &quot;C&quot;, _point = Point { _x = 1.0, _y = 2.0 } }
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let atom2 = Atom { _element = &quot;O&quot;, _point = Point { _x = 3.0, _y = 4.0 } }
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let molecule = Molecule { _atoms = [atom1, atom2] }
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>view (atoms . traverse . element) molecule
</code></strong>&quot;CO&quot;
</pre><p>This works because our traversal's result is a <code><a href="/package/base-4.9.1.0/docs/Data-String.html#t:String">String</a></code>:</p><pre>atoms . traverse . element :: Traversal' Molecule String</pre><p>... and <code><a href="/package/base-4.9.1.0/docs/Data-String.html#t:String">String</a></code> implements the <code><a href="/package/base-4.9.1.0/docs/Data-Monoid.html#t:Monoid">Monoid</a></code> interface.  When you
    try to extract multiple strings using <code><a href="/package/lens-4.15.3/docs/Control-Lens-Getter.html#v:view">view</a></code> they get flattened together
    into a single <code><a href="/package/base-4.9.1.0/docs/Data-String.html#t:String">String</a></code> using <code><a href="/package/base-4.9.1.0/docs/Data-Monoid.html#v:mappend">mappend</a></code>.</p><p>If you try to extract the element from an empty molecule:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>view (atoms . traverse . element) (Molecule { _atoms = [] })
</code></strong>&quot;&quot;
</pre><p>You get the empty string (i.e. <code><a href="/package/base-4.9.1.0/docs/Data-Monoid.html#v:mempty">mempty</a></code>).</p><p>This is why the result of a <code><a href="/package/lens-4.15.3/docs/Control-Lens-Type.html#t:Traversal-39-">Traversal'</a></code> needs to be a <code><a href="/package/base-4.9.1.0/docs/Data-Monoid.html#t:Monoid">Monoid</a></code>
    when using <code><a href="/package/lens-4.15.3/docs/Control-Lens-Getter.html#v:view">view</a></code>.  If the <code><a href="/package/lens-4.15.3/docs/Control-Lens-Type.html#t:Traversal-39-">Traversal'</a></code> points to more than one value you
    need some way to combine them into a single value (using
    <code><a href="/package/base-4.9.1.0/docs/Data-Monoid.html#v:mappend">mappend</a></code>) and if the <code><a href="/package/lens-4.15.3/docs/Control-Lens-Type.html#t:Traversal-39-">Traversal'</a></code> points to less than one
    value you need a default value to return (using <code><a href="/package/base-4.9.1.0/docs/Data-Monoid.html#v:mempty">mempty</a></code>).</p><p>If you try to <code><a href="/package/lens-4.15.3/docs/Control-Lens-Getter.html#v:view">view</a></code> a <code><a href="/package/lens-4.15.3/docs/Control-Lens-Type.html#t:Traversal-39-">Traversal'</a></code> that doesn't point to a
    <code><a href="/package/base-4.9.1.0/docs/Data-Monoid.html#t:Monoid">Monoid</a></code>, you will get the following type error:</p><pre>&gt;&gt;&gt; view (atoms . traverse . point . x) molecule
    No instance for (Data.Monoid.Monoid Double)
      arising from a use of `traverse'
    In the first argument of `(.)', namely `traverse'
    In the second argument of `(.)', namely `traverse . point . x'
    In the first argument of `view', namely
      `(atoms . traverse . point . x)'</pre><p>The compiler complains that <code><a href="/package/base-4.9.1.0/docs/Prelude.html#t:Double">Double</a></code> does not implement the
    <code><a href="/package/base-4.9.1.0/docs/Data-Monoid.html#t:Monoid">Monoid</a></code> type class, so there is no sensible way to merge all
    the x coordinates that our <code><a href="/package/lens-4.15.3/docs/Control-Lens-Type.html#t:Traversal-39-">Traversal'</a></code> points to.  For these cases you
    should use <code><a href="/package/lens-4.15.3/docs/Control-Lens-Fold.html#v:toListOf">toListOf</a></code> instead.</p></div><h1 id="g:7">Drawbacks</h1><div class="doc"><p>Lenses come with trade-offs, so you should use them wisely.</p><p>For example, lenses do not produce the best error messages.  Unless you
    understand how <code><a href="/package/lens-4.15.3/docs/Control-Lens-Type.html#t:Traversal-39-">Traversal'</a></code>s work you will probably not understand the
    above error message.</p><p>Also, lenses increase the learning curve for new Haskell programmers, so
    you should consider avoiding them in tutorial code targeting novice
    Haskell programmers.</p><p>Lenses also add a level of boilerplate to all data types to auto-generate
    lenses and increase compile times.  So for small projects the overhead of
    adding lenses may dwarf the benefits.</p><p><code>lens</code> is also a library with a large dependency tree, focused on being
    &quot;batteries included&quot; and covering a large cross-section of the Haskell
    ecosystem. Browsing the Hackage listing you will find support modules
    ranging from <a href="/package/lens-4.15.3/docs/System-FilePath-Lens.html">System.FilePath.Lens</a> to <a href="/package/lens-4.15.3/docs/Control-Parallel-Strategies-Lens.html">Control.Parallel.Strategies.Lens</a>,
    and many more. If you need a more light-weight alternative you can use
    the <code>lens-simple</code> or <code>microlens</code> library, each of which provides a
    restricted subset of the <code>lens</code> library with a much smaller dependency tree.</p><p>The ideal use case for the <code>lens</code> library is a medium-to-large project with
    rich and deeply nested types.  In these large projects the benefits of using
    lenses outweigh the costs.</p></div><h1 id="g:8">Conclusion</h1><div class="doc"><p>This tutorial covers an extremely small subset of this library.  If you
    would like to learn more, you can begin by skimming the example code in the
    following modules:</p><ul><li><a href="/package/lens-4.15.3/docs/Control-Lens-Getter.html">Control.Lens.Getter</a></li><li><a href="/package/lens-4.15.3/docs/Control-Lens-Setter.html">Control.Lens.Setter</a></li><li><a href="/package/lens-4.15.3/docs/Control-Lens-Traversal.html">Control.Lens.Traversal</a></li><li><a href="/package/lens-4.15.3/docs/Control-Lens-Tuple.html">Control.Lens.Tuple</a></li><li><a href="/package/lens-4.15.3/docs/Control-Lens-Lens.html">Control.Lens.Lens</a></li><li><a href="/package/lens-4.15.3/docs/Control-Lens-Review.html">Control.Lens.Review</a></li><li><a href="/package/lens-4.15.3/docs/Control-Lens-Prism.html">Control.Lens.Prism</a></li><li><a href="/package/lens-4.15.3/docs/Control-Lens-Iso.html">Control.Lens.Iso</a></li></ul><p>The documentation for these modules includes several examples to get you
    started and help you build an intuition for more advanced tricks that were
    not covered in this tutorial.</p><p>You can also study several long-form examples here:</p><p><a href="https://github.com/ekmett/lens/tree/master/examples">https://github.com/ekmett/lens/tree/master/examples</a></p><p>If you prefer light-weight <code>lens</code>-compatible libraries, then check out
    <code>lens-simple</code> or <code>micro-lens</code>:</p><ul><li><a href="http://hackage.haskell.org/package/microlens">microlens</a></li><li><a href="http://hackage.haskell.org/package/lens-simple">lens-simple</a></li></ul><p>If you would like a broader survey of lens features, then you can check
    out these tutorials:</p><ul><li><a href="https://www.fpcomplete.com/school/to-infinity-and-beyond/pick-of-the-week/a-little-lens-starter-tutorial">A little lens starter tutorial</a> - Introduces
Prisms, Isos and JSON functionality</li><li><a href="http://www.haskellforall.com/2013/05/program-imperatively-using-haskell.html">Program imperatively using Haskell lenses</a> - Illustrates lens support for stateful code</li></ul></div><h1 id="g:9">Exports</h1><div class="doc"><p>These are the same types and lenses used throughout the tutorial, exported
    for your convenience.</p></div><div class="top"><p class="src"><span class="keyword">data</span> <a id="t:Atom" class="def">Atom</a> <a href="src/Control-Lens-Tutorial.html#Atom" class="link">Source</a> <a href="#t:Atom" class="selflink">#</a></p><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a id="v:Atom" class="def">Atom</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div class="subs fields"><p class="caption">Fields</p><ul><li><dfn class="src"><a id="v:_element" class="def">_element</a> :: <a href="/package/base-4.9.1.0/docs/Data-String.html#t:String">String</a></dfn><div class="doc empty">&nbsp;</div></li><li><dfn class="src"><a id="v:_point" class="def">_point</a> :: <a href="Control-Lens-Tutorial.html#t:Point">Point</a></dfn><div class="doc empty">&nbsp;</div></li></ul></div></td></tr></table></div><div class="subs instances"><p id="control.i:Atom" class="caption collapser" onclick="toggleSection('i:Atom')">Instances</p><div id="section.i:Atom" class="show"><table><tr><td class="src clearfix"><span class="inst-left"><span id="control.i:id:Atom:Show:1" class="instance expander" onclick="toggleSection('i:id:Atom:Show:1')"></span> <a href="/package/base-4.9.1.0/docs/Text-Show.html#t:Show">Show</a> <a href="Control-Lens-Tutorial.html#t:Atom">Atom</a></span> <a href="src/Control-Lens-Tutorial.html#line-865" class="link">Source</a> <a href="#t:Atom" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div id="section.i:id:Atom:Show:1" class="inst-details hide"><div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:showsPrec">showsPrec</a> :: <a href="/package/base-4.9.1.0/docs/Data-Int.html#t:Int">Int</a> -&gt; <a href="Control-Lens-Tutorial.html#t:Atom">Atom</a> -&gt; <a href="/package/base-4.9.1.0/docs/Text-Show.html#t:ShowS">ShowS</a> <a href="#v:showsPrec" class="selflink">#</a></p><p class="src"><a href="#v:show">show</a> :: <a href="Control-Lens-Tutorial.html#t:Atom">Atom</a> -&gt; <a href="/package/base-4.9.1.0/docs/Data-String.html#t:String">String</a> <a href="#v:show" class="selflink">#</a></p><p class="src"><a href="#v:showList">showList</a> :: [<a href="Control-Lens-Tutorial.html#t:Atom">Atom</a>] -&gt; <a href="/package/base-4.9.1.0/docs/Text-Show.html#t:ShowS">ShowS</a> <a href="#v:showList" class="selflink">#</a></p></div></div></td></tr></table></div></div></div><div class="top"><p class="src"><a id="v:element" class="def">element</a> :: <a href="/package/lens-4.15.3/docs/Control-Lens-Type.html#t:Lens-39-">Lens'</a> <a href="Control-Lens-Tutorial.html#t:Atom">Atom</a> <a href="/package/base-4.9.1.0/docs/Data-String.html#t:String">String</a> <a href="src/Control-Lens-Tutorial.html#element" class="link">Source</a> <a href="#v:element" class="selflink">#</a></p></div><div class="top"><p class="src"><a id="v:point" class="def">point</a> :: <a href="/package/lens-4.15.3/docs/Control-Lens-Type.html#t:Lens-39-">Lens'</a> <a href="Control-Lens-Tutorial.html#t:Atom">Atom</a> <a href="Control-Lens-Tutorial.html#t:Point">Point</a> <a href="src/Control-Lens-Tutorial.html#point" class="link">Source</a> <a href="#v:point" class="selflink">#</a></p></div><div class="top"><p class="src"><span class="keyword">data</span> <a id="t:Point" class="def">Point</a> <a href="src/Control-Lens-Tutorial.html#Point" class="link">Source</a> <a href="#t:Point" class="selflink">#</a></p><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a id="v:Point" class="def">Point</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div class="subs fields"><p class="caption">Fields</p><ul><li><dfn class="src"><a id="v:_x" class="def">_x</a> :: <a href="/package/base-4.9.1.0/docs/Prelude.html#t:Double">Double</a></dfn><div class="doc empty">&nbsp;</div></li><li><dfn class="src"><a id="v:_y" class="def">_y</a> :: <a href="/package/base-4.9.1.0/docs/Prelude.html#t:Double">Double</a></dfn><div class="doc empty">&nbsp;</div></li></ul></div></td></tr></table></div><div class="subs instances"><p id="control.i:Point" class="caption collapser" onclick="toggleSection('i:Point')">Instances</p><div id="section.i:Point" class="show"><table><tr><td class="src clearfix"><span class="inst-left"><span id="control.i:id:Point:Show:1" class="instance expander" onclick="toggleSection('i:id:Point:Show:1')"></span> <a href="/package/base-4.9.1.0/docs/Text-Show.html#t:Show">Show</a> <a href="Control-Lens-Tutorial.html#t:Point">Point</a></span> <a href="src/Control-Lens-Tutorial.html#line-867" class="link">Source</a> <a href="#t:Point" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div id="section.i:id:Point:Show:1" class="inst-details hide"><div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:showsPrec">showsPrec</a> :: <a href="/package/base-4.9.1.0/docs/Data-Int.html#t:Int">Int</a> -&gt; <a href="Control-Lens-Tutorial.html#t:Point">Point</a> -&gt; <a href="/package/base-4.9.1.0/docs/Text-Show.html#t:ShowS">ShowS</a> <a href="#v:showsPrec" class="selflink">#</a></p><p class="src"><a href="#v:show">show</a> :: <a href="Control-Lens-Tutorial.html#t:Point">Point</a> -&gt; <a href="/package/base-4.9.1.0/docs/Data-String.html#t:String">String</a> <a href="#v:show" class="selflink">#</a></p><p class="src"><a href="#v:showList">showList</a> :: [<a href="Control-Lens-Tutorial.html#t:Point">Point</a>] -&gt; <a href="/package/base-4.9.1.0/docs/Text-Show.html#t:ShowS">ShowS</a> <a href="#v:showList" class="selflink">#</a></p></div></div></td></tr></table></div></div></div><div class="top"><p class="src"><a id="v:x" class="def">x</a> :: <a href="/package/lens-4.15.3/docs/Control-Lens-Type.html#t:Lens-39-">Lens'</a> <a href="Control-Lens-Tutorial.html#t:Point">Point</a> <a href="/package/base-4.9.1.0/docs/Prelude.html#t:Double">Double</a> <a href="src/Control-Lens-Tutorial.html#x" class="link">Source</a> <a href="#v:x" class="selflink">#</a></p></div><div class="top"><p class="src"><a id="v:y" class="def">y</a> :: <a href="/package/lens-4.15.3/docs/Control-Lens-Type.html#t:Lens-39-">Lens'</a> <a href="Control-Lens-Tutorial.html#t:Point">Point</a> <a href="/package/base-4.9.1.0/docs/Prelude.html#t:Double">Double</a> <a href="src/Control-Lens-Tutorial.html#y" class="link">Source</a> <a href="#v:y" class="selflink">#</a></p></div><div class="top"><p class="src"><span class="keyword">data</span> <a id="t:Molecule" class="def">Molecule</a> <a href="src/Control-Lens-Tutorial.html#Molecule" class="link">Source</a> <a href="#t:Molecule" class="selflink">#</a></p><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a id="v:Molecule" class="def">Molecule</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div class="subs fields"><p class="caption">Fields</p><ul><li><dfn class="src"><a id="v:_atoms" class="def">_atoms</a> :: [<a href="Control-Lens-Tutorial.html#t:Atom">Atom</a>]</dfn><div class="doc empty">&nbsp;</div></li></ul></div></td></tr></table></div><div class="subs instances"><p id="control.i:Molecule" class="caption collapser" onclick="toggleSection('i:Molecule')">Instances</p><div id="section.i:Molecule" class="show"><table><tr><td class="src clearfix"><span class="inst-left"><span id="control.i:id:Molecule:Show:1" class="instance expander" onclick="toggleSection('i:id:Molecule:Show:1')"></span> <a href="/package/base-4.9.1.0/docs/Text-Show.html#t:Show">Show</a> <a href="Control-Lens-Tutorial.html#t:Molecule">Molecule</a></span> <a href="src/Control-Lens-Tutorial.html#line-869" class="link">Source</a> <a href="#t:Molecule" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div id="section.i:id:Molecule:Show:1" class="inst-details hide"><div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:showsPrec">showsPrec</a> :: <a href="/package/base-4.9.1.0/docs/Data-Int.html#t:Int">Int</a> -&gt; <a href="Control-Lens-Tutorial.html#t:Molecule">Molecule</a> -&gt; <a href="/package/base-4.9.1.0/docs/Text-Show.html#t:ShowS">ShowS</a> <a href="#v:showsPrec" class="selflink">#</a></p><p class="src"><a href="#v:show">show</a> :: <a href="Control-Lens-Tutorial.html#t:Molecule">Molecule</a> -&gt; <a href="/package/base-4.9.1.0/docs/Data-String.html#t:String">String</a> <a href="#v:show" class="selflink">#</a></p><p class="src"><a href="#v:showList">showList</a> :: [<a href="Control-Lens-Tutorial.html#t:Molecule">Molecule</a>] -&gt; <a href="/package/base-4.9.1.0/docs/Text-Show.html#t:ShowS">ShowS</a> <a href="#v:showList" class="selflink">#</a></p></div></div></td></tr></table></div></div></div><div class="top"><p class="src"><a id="v:atoms" class="def">atoms</a> :: <a href="/package/lens-4.15.3/docs/Control-Lens-Type.html#t:Iso-39-">Iso'</a> <a href="Control-Lens-Tutorial.html#t:Molecule">Molecule</a> [<a href="Control-Lens-Tutorial.html#t:Atom">Atom</a>] <a href="src/Control-Lens-Tutorial.html#atoms" class="link">Source</a> <a href="#v:atoms" class="selflink">#</a></p></div><div class="top"><p class="src"><span class="keyword">data</span> <a id="t:Pair" class="def">Pair</a> a <a href="src/Control-Lens-Tutorial.html#Pair" class="link">Source</a> <a href="#t:Pair" class="selflink">#</a></p><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a id="v:Pair" class="def">Pair</a> a a</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="subs instances"><p id="control.i:Pair" class="caption collapser" onclick="toggleSection('i:Pair')">Instances</p><div id="section.i:Pair" class="show"><table><tr><td class="src clearfix"><span class="inst-left"><span id="control.i:id:Pair:Functor:1" class="instance expander" onclick="toggleSection('i:id:Pair:Functor:1')"></span> <a href="/package/base-4.9.1.0/docs/Data-Functor.html#t:Functor">Functor</a> <a href="Control-Lens-Tutorial.html#t:Pair">Pair</a></span> <a href="src/Control-Lens-Tutorial.html#line-871" class="link">Source</a> <a href="#t:Pair" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div id="section.i:id:Pair:Functor:1" class="inst-details hide"><div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:fmap">fmap</a> :: (a -&gt; b) -&gt; <a href="Control-Lens-Tutorial.html#t:Pair">Pair</a> a -&gt; <a href="Control-Lens-Tutorial.html#t:Pair">Pair</a> b <a href="#v:fmap" class="selflink">#</a></p><p class="src"><a href="#v:-60--36-">(&lt;$)</a> :: a -&gt; <a href="Control-Lens-Tutorial.html#t:Pair">Pair</a> b -&gt; <a href="Control-Lens-Tutorial.html#t:Pair">Pair</a> a <a href="#v:-60--36-" class="selflink">#</a></p></div></div></td></tr><tr><td class="src clearfix"><span class="inst-left"><span id="control.i:id:Pair:Foldable:2" class="instance expander" onclick="toggleSection('i:id:Pair:Foldable:2')"></span> <a href="/package/base-4.9.1.0/docs/Data-Foldable.html#t:Foldable">Foldable</a> <a href="Control-Lens-Tutorial.html#t:Pair">Pair</a></span> <a href="src/Control-Lens-Tutorial.html#line-871" class="link">Source</a> <a href="#t:Pair" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div id="section.i:id:Pair:Foldable:2" class="inst-details hide"><div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:fold">fold</a> :: <a href="/package/base-4.9.1.0/docs/Data-Monoid.html#t:Monoid">Monoid</a> m =&gt; <a href="Control-Lens-Tutorial.html#t:Pair">Pair</a> m -&gt; m <a href="#v:fold" class="selflink">#</a></p><p class="src"><a href="#v:foldMap">foldMap</a> :: <a href="/package/base-4.9.1.0/docs/Data-Monoid.html#t:Monoid">Monoid</a> m =&gt; (a -&gt; m) -&gt; <a href="Control-Lens-Tutorial.html#t:Pair">Pair</a> a -&gt; m <a href="#v:foldMap" class="selflink">#</a></p><p class="src"><a href="#v:foldr">foldr</a> :: (a -&gt; b -&gt; b) -&gt; b -&gt; <a href="Control-Lens-Tutorial.html#t:Pair">Pair</a> a -&gt; b <a href="#v:foldr" class="selflink">#</a></p><p class="src"><a href="#v:foldr-39-">foldr'</a> :: (a -&gt; b -&gt; b) -&gt; b -&gt; <a href="Control-Lens-Tutorial.html#t:Pair">Pair</a> a -&gt; b <a href="#v:foldr-39-" class="selflink">#</a></p><p class="src"><a href="#v:foldl">foldl</a> :: (b -&gt; a -&gt; b) -&gt; b -&gt; <a href="Control-Lens-Tutorial.html#t:Pair">Pair</a> a -&gt; b <a href="#v:foldl" class="selflink">#</a></p><p class="src"><a href="#v:foldl-39-">foldl'</a> :: (b -&gt; a -&gt; b) -&gt; b -&gt; <a href="Control-Lens-Tutorial.html#t:Pair">Pair</a> a -&gt; b <a href="#v:foldl-39-" class="selflink">#</a></p><p class="src"><a href="#v:foldr1">foldr1</a> :: (a -&gt; a -&gt; a) -&gt; <a href="Control-Lens-Tutorial.html#t:Pair">Pair</a> a -&gt; a <a href="#v:foldr1" class="selflink">#</a></p><p class="src"><a href="#v:foldl1">foldl1</a> :: (a -&gt; a -&gt; a) -&gt; <a href="Control-Lens-Tutorial.html#t:Pair">Pair</a> a -&gt; a <a href="#v:foldl1" class="selflink">#</a></p><p class="src"><a href="#v:toList">toList</a> :: <a href="Control-Lens-Tutorial.html#t:Pair">Pair</a> a -&gt; [a] <a href="#v:toList" class="selflink">#</a></p><p class="src"><a href="#v:null">null</a> :: <a href="Control-Lens-Tutorial.html#t:Pair">Pair</a> a -&gt; <a href="/package/base-4.9.1.0/docs/Data-Bool.html#t:Bool">Bool</a> <a href="#v:null" class="selflink">#</a></p><p class="src"><a href="#v:length">length</a> :: <a href="Control-Lens-Tutorial.html#t:Pair">Pair</a> a -&gt; <a href="/package/base-4.9.1.0/docs/Data-Int.html#t:Int">Int</a> <a href="#v:length" class="selflink">#</a></p><p class="src"><a href="#v:elem">elem</a> :: <a href="/package/base-4.9.1.0/docs/Data-Eq.html#t:Eq">Eq</a> a =&gt; a -&gt; <a href="Control-Lens-Tutorial.html#t:Pair">Pair</a> a -&gt; <a href="/package/base-4.9.1.0/docs/Data-Bool.html#t:Bool">Bool</a> <a href="#v:elem" class="selflink">#</a></p><p class="src"><a href="#v:maximum">maximum</a> :: <a href="/package/base-4.9.1.0/docs/Data-Ord.html#t:Ord">Ord</a> a =&gt; <a href="Control-Lens-Tutorial.html#t:Pair">Pair</a> a -&gt; a <a href="#v:maximum" class="selflink">#</a></p><p class="src"><a href="#v:minimum">minimum</a> :: <a href="/package/base-4.9.1.0/docs/Data-Ord.html#t:Ord">Ord</a> a =&gt; <a href="Control-Lens-Tutorial.html#t:Pair">Pair</a> a -&gt; a <a href="#v:minimum" class="selflink">#</a></p><p class="src"><a href="#v:sum">sum</a> :: <a href="/package/base-4.9.1.0/docs/Prelude.html#t:Num">Num</a> a =&gt; <a href="Control-Lens-Tutorial.html#t:Pair">Pair</a> a -&gt; a <a href="#v:sum" class="selflink">#</a></p><p class="src"><a href="#v:product">product</a> :: <a href="/package/base-4.9.1.0/docs/Prelude.html#t:Num">Num</a> a =&gt; <a href="Control-Lens-Tutorial.html#t:Pair">Pair</a> a -&gt; a <a href="#v:product" class="selflink">#</a></p></div></div></td></tr><tr><td class="src clearfix"><span class="inst-left"><span id="control.i:id:Pair:Traversable:3" class="instance expander" onclick="toggleSection('i:id:Pair:Traversable:3')"></span> <a href="/package/base-4.9.1.0/docs/Data-Traversable.html#t:Traversable">Traversable</a> <a href="Control-Lens-Tutorial.html#t:Pair">Pair</a></span> <a href="src/Control-Lens-Tutorial.html#line-871" class="link">Source</a> <a href="#t:Pair" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div id="section.i:id:Pair:Traversable:3" class="inst-details hide"><div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:traverse">traverse</a> :: <a href="/package/base-4.9.1.0/docs/Control-Applicative.html#t:Applicative">Applicative</a> f =&gt; (a -&gt; f b) -&gt; <a href="Control-Lens-Tutorial.html#t:Pair">Pair</a> a -&gt; f (<a href="Control-Lens-Tutorial.html#t:Pair">Pair</a> b) <a href="#v:traverse" class="selflink">#</a></p><p class="src"><a href="#v:sequenceA">sequenceA</a> :: <a href="/package/base-4.9.1.0/docs/Control-Applicative.html#t:Applicative">Applicative</a> f =&gt; <a href="Control-Lens-Tutorial.html#t:Pair">Pair</a> (f a) -&gt; f (<a href="Control-Lens-Tutorial.html#t:Pair">Pair</a> a) <a href="#v:sequenceA" class="selflink">#</a></p><p class="src"><a href="#v:mapM">mapM</a> :: <a href="/package/base-4.9.1.0/docs/Control-Monad.html#t:Monad">Monad</a> m =&gt; (a -&gt; m b) -&gt; <a href="Control-Lens-Tutorial.html#t:Pair">Pair</a> a -&gt; m (<a href="Control-Lens-Tutorial.html#t:Pair">Pair</a> b) <a href="#v:mapM" class="selflink">#</a></p><p class="src"><a href="#v:sequence">sequence</a> :: <a href="/package/base-4.9.1.0/docs/Control-Monad.html#t:Monad">Monad</a> m =&gt; <a href="Control-Lens-Tutorial.html#t:Pair">Pair</a> (m a) -&gt; m (<a href="Control-Lens-Tutorial.html#t:Pair">Pair</a> a) <a href="#v:sequence" class="selflink">#</a></p></div></div></td></tr></table></div></div></div><div class="top"><p class="src"><a id="v:traverse" class="def">traverse</a> :: <a href="/package/base-4.9.1.0/docs/Data-Traversable.html#t:Traversable">Traversable</a> t =&gt; <span class="keyword">forall</span> f a b. <a href="/package/base-4.9.1.0/docs/Control-Applicative.html#t:Applicative">Applicative</a> f =&gt; (a -&gt; f b) -&gt; t a -&gt; f (t b) <a href="#v:traverse" class="selflink">#</a></p><div class="doc"><p>Map each element of a structure to an action, evaluate these actions
 from left to right, and collect the results. For a version that ignores
 the results see <code><a href="/package/base-4.9.1.0/docs/Data-Foldable.html#v:traverse_">traverse_</a></code>.</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.17.3</p></div></body></html>
